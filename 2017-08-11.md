<!-- page_number: true -->
<!-- $size: 16:9 -->

# C++ Club

## 11 August 2017

---

# Toronto trip report by Andrew Pardoe (MSFT)

[Post](https://blogs.msdn.microsoft.com/vcblog/2017/07/28/trip-report-evolution-working-group-at-the-summer-iso-c-standards-meeting-toronto/)

* Biggest news: [Concepts TS](https://wg21.link/p0734) merged into [C++ draft standard](https://wg21.link/n4659)
	* EWG is committed to bringing back an abbreviated syntax in future meetings, ideally before C++20 is finished. [P0694R0](https://wg21.link/P0694) is a paper by Bjarne Stroustrup on the natural syntax.
* [Modules TS](https://wg21.link/n4610) discussions in detail
* Other proposals described in detail
* Discouraged proposals

---

# Toronto trip report by Botond Ballo

* [Post](https://botondballo.wordpress.com/2017/08/02/trip-report-c-standards-meeting-in-toronto-july-2017/)
* [Reddit thread](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/)
* Detailed EWG report
* Rejected proposals
* Detailed report on Concepts TS

> AFTs have been controversial since their introduction, due to their ability to make template code look like non-template code. Many have argued that this is a bad idea, beacuse template code is fundamentally different from non-template code (e.g. consider different name lookup rules, the need for syntactic disambiguators like typename, and the ability to define a function out of line). Others have argued that making generic programming (programming with templates) look more like regular programming is a good thing.

---

# Botond Ballo's report (cont.)

> I really don't understand this desire for a syntactic marker. IDEs are perfectly capable of semantic highlighting [#](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/dl2r838/)

> I don't think it's really so important to recognize templates that they need to be called out that way at all [#](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/dl3ntiu/)

> more than 30 years ago, when overloading was introduced in C++ there was a requirement of an overload declaration with the overload keyword. It didn't work out [#](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/dl3ntiu/)

> I actually can't remember if I have ever wanted to know whether a function is a template or not <...> You should not program in 2017 using 20 year old tools, nor should a language feature implemented in 2017 be designed with 20 year old tools in mind. [#](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/dl3hzmm/)

> <...> not everyone uses editors with semantic highlighting capabilities, and that people often look at code in non-editor contexts like code review tools
>> The language should not accumulate cruft to accommodate 10 year old tools [#](https://www.reddit.com/r/cpp/comments/6r54xc/trip_report_c_standards_meeting_in_toronto_july/dl3hfo1/)

---

# [What should the C++ Standards Committee be doing?](https://isocpp.org/blog/2017/07/what-should-the-iso-cpp-standards-committee-be-doing)

1. Compile-time stability: Every change in behavior in a new version of the standard is detectable by a compiler for the previous version.
2. Link-time stability: ABI breakage is avoided except in very rare cases, which will be welldocumented and supported by a written rationale.
3. Compiler performance stability: Changes will not imply significant added compile-time costs for existing code.
4. Run-time Performance stability: Changes will not imply added run-time costs to existing code.
5. Progress: Every revision of the standard will offer improved support for some significant programming activity or community.
6. Simplicity: Every revision of the standard will offer some simplification of some significant programming activity.
7. Timeliness: The next revision of the standard will be shipped on time according to a published schedule.

---

# What should the ISO C++ Standards Committee be doing? (cont.)

* [Reddit thread](https://www.reddit.com/r/cpp/comments/6qoz9e/what_should_the_iso_c_standards_committee_be_doing/)
    * [Robert Ramey's comment](https://www.reddit.com/r/cpp/comments/6qoz9e/what_should_the_iso_c_standards_committee_be_doing/dkyyhra/)
    * [Z01dbrg's negative comment and responses by Louis Dionne](https://www.reddit.com/r/cpp/comments/6qoz9e/what_should_the_iso_c_standards_committee_be_doing/dkyxqsy/)
    * [Gabriel Dos Reis's comment](https://www.reddit.com/r/cpp/comments/6qoz9e/what_should_the_iso_c_standards_committee_be_doing/dl1zas7/)

---

# Precompiled header issues and recommendations

[Andrew Pardoe et al., Microsoft](https://blogs.msdn.microsoft.com/vcblog/2017/07/13/precompiled-header-pch-issues-and-recommendations/)

* Move to a newer compiler, use x64 compiler
* Multi-CPU systems: Failure to automatically increase the pagefile size (Windows bug)
* Pass `/p:PreferredToolArchtecture=x64` to MSBuild
* Use `/MP` compiler option ([Details](https://docs.microsoft.com/en-us/cpp/build/reference/mp-build-with-multiple-processes))
* Don't use `#pragma hdrstop`, use `/Fp<PCH-file-name>` instead

---

# Undocumented MSVC options for build timing

* Compiler: `/Bt+`
* Linker: `/time+`
* Source: [Going Native 35](https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-35-Fast-Tips-for-Faster-Builds)

---

# Using Trompeloeil (Björn Fahller)

## A mocking framework for modern C++ (C++14, single header)

* [NDC Oslo, June 2017](https://www.youtube.com/watch?v=vvQ-kK4coYM)
* [ACCU 2017, May 2017](https://www.youtube.com/watch?v=HCh6cs9nXt0)
* [Sweden C++, Septenber 2016](https://www.youtube.com/watch?v=mPYNsARvTDk)
* [GitHub](https://github.com/rollbear/trompeloeil) (Boost licence)
* [Cheatsheet (PDF)](https://github.com/rollbear/trompeloeil/blob/master/docs/trompeloeil_cheat_sheet.pdf)

---

# cppcoro: a library of coroutine abstractions

> The 'cppcoro' library provides a set of general-purpose primitives for making use of the coroutines TS proposal described in N4628.

[GitHub](https://github.com/lewissbaker/cppcoro)

* Coroutine types: `task<T>`, `lazy_task<T>`, `shared_task<T>`, `shared_lazy_task<T>`, `generator<T>`, `recursive_generator<T>`, `async_generator<T>`
* Awaitable types: `single_consumer_event`, `async_mutex`, `async_manual_reset_event`, `async_auto_reset_event`
* Cancellation: `cancellation_token`, `cancellation_source`, `cancellation_registration`
* Schedulers and I/O: `io_service`, `io_work_scope`, `file`, `readable_file`, `writable_file`, `read_only_file`, `write_only_file`, `read_write_file`

---

# Your own error code

[Post](https://akrzemi1.wordpress.com/2017/07/12/your-own-error-code/)

* _System error support in C++0x_ by Chris Kohlhoff: [Part 1](http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html), [Part 2](http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html), [Part 3](http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html), [Part 4](http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html), [Part 5](http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html)
* `std::error_code`

---

# DIMWITS: DIMensional analysis With unITS

[GitHub](https://github.com/njoy/dimensionalanalysis) -- C++14, Copyright (c) 2016, Los Alamos National Security, LLC

```cpp
/* quantities play nicely with auto */
auto myVelocity = 1.0 * meter / second;
std::cout << "The speed is: " << myVelocity << std::endl;

/* quantities of the same dimensionality can be implicitly converted */
Quantity<Foot> myLength = 1.0 * meter;
std::cout << "1 meter in feet is: " << myLength << std::endl;

/* si-prefixes can be specified on either side of the assignment */
Quantity<Kilo<Gram>> myMass = 1.0 * mega(tonne);
std::cout << "1 megatonne in kilograms is: " << myMass << std::endl;

/* NIST values for common physical constants are provided */
std::cout << "The speed of light is: " << constant::lightSpeed << std::endl;
```

---

# sltbench: a C++ micro-benchmarking tool

[GitHub](https://github.com/ivafanas/sltbench) -- Apache 2.0 licence

* 4.7x times faster than googlebench

```cpp
void my_function()
{
    std::vector<size_t> v(100000, 0);
    std::sort(v.begin(), v.end());
}

SLTBENCH_FUNCTION(my_function);

SLTBENCH_MAIN();
```

---

# spdlog: an ultra-fast C++ logging library

[GitHub](https://github.com/gabime/spdlog) -- C++11, MIT licence

* header-only
* Linux, FreeBSD, Solaris, Mac OS, Windows, Android
* Uses **{fmt}** library for formatting
* Async mode using lock-free queues
* Custom formatting
* Conditional logging
* Targets: rotating/daily log files, console (w/colour), syslog, Windows debugger
* Severity-based filtering

---

# MPark.Variant: C++17 std::variant for C++11/14/17

[GitHub](https://github.com/mpark/variant) -- C++11, Boost Licence

* Based on libc++ implementation of `std::variant` (same author)
* Continuously tested against libc++'s `std::variant` test suite
* Single-header
* [Documentation](http://en.cppreference.com/w/cpp/utility/variant)

---

# The long-arrow operator in C++

[By Ivan Čukić](http://cukic.co/2017/07/12/the-long-arrow-operator-in-cxx/)

```cpp
template <typename T>
class wrap {
public:
    T* operator->()    { return &t; }
    T& operator--(int) {  return t; }

private:
    T t;
};

wrap<wrap<std::string>> wp1;
wp1--->length();

wrap<wrap<wrap<std::string>>> wp2;
wp2----->length();
```

---

# Outcome v2 is stable

* [Reddit post](https://www.reddit.com/r/cpp/comments/6qo1m3/outcome_v2_has_reached_stability_wg21_paper_will/)
* Ready for the 2nd Boost review
* Deployed in 2 libs
* Shots fired!

> I know those coming from Rust-land feel amazement how long it has taken C++ to replicate Rust's `Result<T, E>`, but I'm very sure ours is enormously superior to theirs already simply by doing so much less because it doesn't need to. Taking time to get design right is one of the big things which continues to separate C++ from the upstart systems programming languages. Long may it continue!

* You'll never guess what happened next.

---

# Cfront rel. 1

[Source](http://www.softwarepreservation.org/projects/c_plus_plus/cfront/release_1.0/src/cfront/src/)

---

# Sweden CPP conference

* [Meetup](http://www.meetup.com/swedencpp)
* [YouTube](https://www.youtube.com/channel/UC_LAXFBuK7J2J6NLiYzdPEA/videos?sort=dd&view=0&shelf_id=0)

---

# Wt: a C++ web toolkit

* [Home page](https://www.webtoolkit.eu/wt/)
* Licence: GPL + commercial
* [GitHub](https://github.com/emweb/wt)

---

# Towards a Good Future

P0676R0, [GitHub](https://github.com/FelixPetriconi/future_proposal/blob/v1.1/proposal.md)

* Based on [Adobe stlab's future](http://www.stlab.cc/libraries/concurrency/future/future/) and [Bloomberg dplp promise](https://github.com/camio/dpl/blob/master/dplp/dplp_promise.h)
* Author recomments against adoption of the proposed `std::future` extensions in Concurrency TS
* `std::future` is crippled
* Futures need to be copyable (currently limited to just one `.then()`)

```cpp
future<int> a;
a.then([](int x){ /* do something */ });
a.then([](int x){ /* also do something else. */ }
```

* Futures need to be cancellable
