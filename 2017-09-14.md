<!-- page_number: true -->
<!-- $theme: default -->

# C++ Club

## 14 September 2017

---

# Boost 1.65.1 released

[Release notes](http://www.boost.org/users/history/version_1_65_1.html)

---

# LLVM 5 released

* [Announcement](http://lists.llvm.org/pipermail/llvm-announce/2017-September/000075.html)

* (Why the big jump from 4.0.1? With the new versioning scheme, the major version is incremented for each major release:
[http://blog.llvm.org/2016/12/llvms-new-versioning-scheme.html](http://blog.llvm.org/2016/12/llvms-new-versioning-scheme.html))
* [Release notes](http://releases.llvm.org/5.0.0/docs/ReleaseNotes.html)

---

# Clang 5 released

* [Release notes](http://releases.llvm.org/5.0.0/tools/clang/docs/ReleaseNotes.html)
* Support for the C++17 standard has been completed.
* C++ coroutines TS implemented
* [New UBSan diagnostics](http://releases.llvm.org/5.0.0/tools/clang/docs/ReleaseNotes.html#undefined-behavior-sanitizer-ubsan)

---

# Hell is a multi-threaded C++ program

[Mark Bessey](http://codemines.blogspot.co.uk/2006/09/hell-is-multi-threaded-c-program.html)

* POSIX Threads, Mach Threads, Windows Threads, Java Threads, and C# Threads all work very much the same.
* The POSIX threading model is just about the simplest possible implementation of multi-threading you could have: all of your threads share the same address space.
* With Pthreads, _it's too easy to make something that almost works_.
* The other major model for multi-threading is known as message-passing multiprocessing: your threads don't share any state by default.
* Two popular variants of the message-passing model are "[Communicating Sequential Processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes)" and the "[Actor model](https://en.wikipedia.org/wiki/Actor_model)".

---

# Another thread on . . . threads

[Mark Bessey](http://codemines.blogspot.co.uk/2006/09/another-thread-on-threads.html)

* Do consider whether you need to use threads at all
* Don't use threads to avoid blocking on I/O
* Do know what each thread in your program is for
  - Don't spawn threads in response to external events
* Don't reinvent the wheel
  - Do stay on the well-trodden path
* Do consider developing a strategy for detecting and/or avoiding deadlocks
* Do consider a message-passing design
* Don't hold a lock or semaphore any longer than actually necessary
* Do use multiple threads to get better performance on multi-processor systems

---

# CppCast: Volta and CUDA C++

[Podcast](http://cppcast.com/2017/09/olivier-giroux/)

Olivier Giroux has worked on eight GPU and four SM architecture generations released by NVIDIA. Lately, he works to clarify the forms and semantics of valid GPU programs, present and future. He was the programming model lead for the new NVIDIA Volta architecture. He is a member of WG21, the ISO C++ committee, and is a passionate contributor to C++'s forward progress guarantees and memory model.

---

# See-phit: A template engine that uses compile-time HTML parsing

* [GitHub](https://github.com/rep-movsd/see-phit)
* C++14 (uses `constexpr` functions)
* Fails to compile if HTML is malformed
* The maximum number of nodes and attributes per parse is hardcoded to 1024
* LGPL 3.0 (how does that even work with a compile-time library?)

---

# Seven Ineffective Coding Habits of Many Programmers

## Kevlin Henney, ITT 2016

[Video](https://www.youtube.com/watch?v=ZsHMHukIlJY)

* Content-to-noise ratio of the code
* Refactoring-safe code formatting
* Naming things

---

# [Zach Laine: Pragmatic Type Erasure](https://www.youtube.com/watch?v=0I0FD3N5cgM)

```cpp
struct anything {
  template<typename T> anything(T t);
  template<typename T> anything& operator =(T t);
  int value() const {return handle_->value();}

  struct handle_base {
    virtual ~handle_base() {}
    virtual handle_base* clone() const = 0;
    virtual int value() const = 0;
  }

  template<typename T>
  struct handle: public handle_base {
    handle(T value);
    virtual handle_base* clone() const;
    virtual int value() const {return value.value();}
    T value;
  }

  std::unique_ptr<handle_base> handle_;
}
```

---

# [Zach Laine: Pragmatic Type Erasure](https://www.youtube.com/watch?v=0I0FD3N5cgM) (cont.)

Pros:

* Value semantics
* Never writing `new` or `delete`
* Ability to bind types to interfaces never seen before, including multiple interfaces
* Thread safety via CoW
* Elision of heap allocations for small types and references

---

# [Zach Laine: Pragmatic Type Erasure](https://www.youtube.com/watch?v=0I0FD3N5cgM) (cont.)

Cons:

* Complex implementation
* Thread safety comes at a cost of atomic operations and copies when values are mutated

---

# [Zach Laine: Pragmatic Type Erasure](https://www.youtube.com/watch?v=0I0FD3N5cgM) (cont.)

* Boost.TypeErasure
* Emtypen: takes a C++ header with one or more interfaces and produces a type-erased version (Clang-based)

---

# [Cheinan Marks: Practical Type Erasure](https://www.youtube.com/watch?v=5PZVuUzP34g)

* Type erasure is the glue between generic and OO code
* Used in `std::shared_ptr`, `std::function`
* Type-safe configuration system using `boost::any`

---

# Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks

## Kevlin Henney, NDC London 2017

[Video](https://www.youtube.com/watch?v=FyCYva9DhsI)

---

# CppCon 2014: Jens Weller "0xBADC0DE"

[Video](https://www.youtube.com/watch?v=JE2WO0G3nCQ)

* Antipatterns
* Bad working environments
* Non-developer managers
* Absence of tests

---

## Hamster wheel can look like a career ladder from the inside.

---

# The original value terminology paper

Bjarne Stroustrup, [PDF](http://www.stroustrup.com/terminology.pdf)

---

#Ã‚Â Accelerating your C++ on GPU with [SYCL](https://www.khronos.org/sycl)

* [Post](https://blog.tartanllama.xyz/sycl/) by Simon Brand ([@TartanLlama](https://twitter.com/TartanLlama))
* Code samples
* Intro to GPGPU computing
* Libraries: [triSYCL](https://github.com/Xilinx/triSYCL) and [ComputeCpp](https://www.codeplay.com/products/computesuite/computecpp)
* [SyclParallelSTL](https://github.com/KhronosGroup/SyclParallelSTL) implements [Parallelism TS](https://github.com/cplusplus/parallelism-ts)

> Transferring data from main memory to the GPU is slow. Really slow. Like, kill all your performance and get you fired slow.

---

#Ã‚Â VXL: Computer vision library

* [Home](http://vxl.sourceforge.net)
* [FAQ](http://vxl.sourceforge.net/vxl-users-faq.html)

---

# C++ Map

* [Original](http://cppmap.jimblog.me/cppmap_v3.png)
* [Local copy](img/cppmap_v3.png)

---

# Polymorphic clones in modern C++

[Jonathan Boccara](https://www.fluentcpp.com/2017/09/08/make-polymorphic-copy-modern-cpp/)

* "virtual constructors" returning covariant bare pointers
* "virtual constructors" returning `unique_ptr<Interface>`
* multiple inheritance: use different "constructor" names

---

# Polymorphic clones in modern C++ (cont.)

[Quentin Duval](https://deque.blog/2017/09/08/how-to-make-a-better-polymorphic-clone/) :: [Reddit](https://www.reddit.com/r/cpp/comments/6yug0q/how_to_make_a_better_polymorphic_clone_in_modern/)

* provide a free function `clone` to wrap the returned pointers in `unique_ptr`
* Non-Virtual Interface + CRTP
* additionally, return pointers using GSL's `owner`
