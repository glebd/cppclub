----

Proper way to iterate backwards in C++
--------------------------------------

https://www.reddit.com/r/cpp/comments/947a1z/proper_way_to_do_backward_iteration_in_c/

.. code:: c++

    for (size_t i = data.size() - 1; i >= 0; --i) { ... } // Nope
    for (size_t i = data.size(); i--;) { ... } // The C way

    // C++17
    std::vector<int> vec;
    for (auto [value, idx] : reverse_index_adapter(vec)) {
        // idx = n-1, n-2, ... 0
    }

    std::for_each(vec.rbegin(), vec.rend(), []() { ... }); // No index

    for (auto it = data.rbegin(); it != data.rend(); ++it) {
        auto i = std::distance(it, data.rend()) - 1;
    }

Move smart pointers in and out functions in modern C++
------------------------------------------------------

* `Move smart pointers in and out functions in modern C++`_
  * Reddit: https://www.reddit.com/r/cpp/comments/aaux96/move_smart_pointers_in_and_out_functions_in/

.. _`Move smart pointers in and out functions in modern C++`: https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c

CppCon 2018 - Andreas Weis - Fixing Two-Phase Initialisation
------------------------------------------------------------

https://youtu.be/S7I66lZX_zM

Inverse two-phase initialisation

.. code:: c++

    class Foo
    {
        static expected<construction_token>
        preconstruct(Arg n_arg) noexcept
        {
            construction_token t;
            t.state = make_unique_nothrow(n_arg);
            if (!t.state) return unexpected(my_errc::error);
            return t;
        }

        Foo(construction_token&& t) noexcept
        : m_state(std::move(t.state)) {}
    };

CppCon 2018 - Andreas Weis - Fixing Two-Phase Initialisation
------------------------------------------------------------

https://youtu.be/S7I66lZX_zM

Inverse two-phase initialisation: usage

.. code:: c++

    // 1
    expected<Foo::construction_token> t1 = Foo::preconstruct(args);
    if (!t1.has_value()) { /* get out */ }
    Foo obj(std::move(*t1));

    // 2
    auto t2 = Foo::preconstruct(args);
    auto obj_ptr = std::make_shared<Foo>(std::move(*t2));

    // 3
    auto t3 = Foo::preconstruct(args);
    std::vector<Foo> objects;
    objects.emplace_back(std::move(*t3));

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

.. code:: c++

    // MSVC rejects, GCC accepts, Clang accepts
    extern extern "C++" extern "C" extern "C++" int x;

    // MSVC accepts, GCC rejects, Clang accepts
    extern "C++" extern "C" extern "C++" extern int x;

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

| *selection-statement:*
|     ``if constexpr``:sub:`opt` ( *init-statement*:sub:`opt` *condition* ) *statement*

.. code:: c++

    if (class foo; !ret.second) /* ... */;

    if (false; true) /* ... */;

    if (; true) /* ... */;

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

Declare and initialise a variable of type "function pointer":

.. code:: c++

    auto (*fp)() -> int(&f);

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

.. code:: c++

    struct foo;
    void bar(foo foo);
    void bar(foo(foo)); // vexing parse
    void bar(foo((foo))); // more vexing parse

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

.. code:: c++

    class bar {};
    int bar;     // OK
    bar b;       // error
    class bar b; // OK
    class std::vector<class bar> bars; // OK

    // also acts as a forward declaration
    void foo(struct S* x);

    // weird scoping rules
    class C { void foo(struct S* x); };
    S* s;

CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

*pseudo-destructor-name*

.. code:: c++

    int i;
    i.~int(); // error: int is not type-name but type-specifier
    using foo = int;
    i.~foo(); // OK
    ~int();   // OK (not a destructor!)


CppCon 2018 - Timur Doumler - I can has grammar?
------------------------------------------------

https://youtu.be/tsG95Y-C14k

Alternative tokens

.. code:: c++

    struct Foo
    {
        Foo();
        compl Foo();
        Foo(const Foo bitand);
        Foo(Foo and);
    };

Twitter
-------

.. image:: img/js-increment.png
